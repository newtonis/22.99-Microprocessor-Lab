/*
 * demodulatorFSK.c
 *
 *  Created on: Oct 18, 2019
 *      Author: martinamaspero
 */

#include "demodulatorFSK.h"
#include "ADC.h"
#include "PIT.h"
#include <stdio.h>
#include <string.h>

#define ADC_CH 0

void filterSignal (void);

int16_t rawData [ DELAY + 1] = {0};
float prefilter[FIR_ORDER+1] = {0};
bool output[60];

int outputCount = 0;
int sampleCount = 0;


static float firCoef[ ] =
		{-0.0018693054003477631f,
		-0.0063458560700613868f,
		-0.011803262238256836f,
		-0.011431063027960632f,
		 0.0055142394274450349f,
		 0.047971856405729658f,
		 0.11520334422221702f,
		 0.1924527660178473f,
		 0.2548404235990876f,
		 0.27884873508664521f,
		 0.2548404235990876f,
		 0.1924527660178473f,
		 0.11520334422221702f,
		 0.047971856405729658f,
		 0.0055142394274450349f,
		-0.011431063027960632f,
		-0.011803262238256836f,
		-0.0063458560700613868f,
		-0.0018693054003477631f };

void FSKdem_init()//callback_t callback)
{
	ADC_init(ADC_CH, FSKdemodulate);
	ADC_enableModule(ADC_CH);

	PIT_init();
	PIT_configTimer(2, 4167, ADC_startConvertion);//4166 es 12k
	PIT_startTime(2);
}


void FSKdemodulate()
{
	updateData( ADC_getDataResult() );
	//memmove( &prefilter[0], &prefilter[1], (FIR_ORDER) * sizeof(float));
	//prefilter[FIR_ORDER] = rawData[DELAY] * rawData[0];
	for(int i=1; i < (1+ FIR_ORDER); i++)
	{
		prefilter[i-1] = prefilter[i];
	}
	prefilter[FIR_ORDER] = rawData[DELAY]*rawData[0];
	sampleCount++;
	if (sampleCount == 1)
	{
		filterSignal();
		sampleCount = 0;
		outputCount++;
		if (outputCount == 50)
			outputCount = 0;
	}

}


void updateData (uint16_t newdata)
{
	for(int i=1; i < (1+ DELAY); i++)
	{
		rawData[i-1] = rawData[i];
	}
	rawData[DELAY] = newdata - 2048;
}

void filterSignal (void)
{
	float aux = 0;

	for (int k = 0; k <= FIR_ORDER ; k++ )
	{
		aux += firCoef[k] * prefilter[FIR_ORDER - k];
	}

	if (aux < 0)
	{
		output[outputCount] = true;
	}
	else
	{
		output[outputCount] = false;
	}

}
