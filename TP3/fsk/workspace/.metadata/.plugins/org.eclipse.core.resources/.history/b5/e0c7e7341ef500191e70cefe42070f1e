

#include "bufferCircular.h"


void cb_init (circularBuffer cb, uint16_t* array, uint8_t len)
{
	cb->buffer = array;
	cb->size = size;
	cb->head = 0;
	cb->tail = 0;
	cb-> count = 0;
}

uint16_t cb_pull (circularBuffer cb)
{
	uint8_t next;
	uint16_t
	val = cb->buffer[]

			 int next;

			 if (c->head == c->tail)  // if the head == tail, we don't have any data
				 return -1;

			 next = c->tail + 1;  // next is where tail will point to after this read.
			 if(next >= c->maxlen)
				 next = 0;

			 *data = c->buffer[c->tail];  // Read data and then move
			 c->tail = next;              // tail to next offset.
			 return 0;  // return success to indicate successful push.


}

int CB_Pull_Front(CIRC_BUFF *circBuff)
{
	int retVal = 0;
	if (CB_Size(circBuff) > 0)
	{
		retVal = circBuff->array[nextIndex(circBuff, circBuff->dataInit)];
		circBuff->dataInit = nextIndex(circBuff, circBuff->dataInit);
	}
	return retVal;
}


int CB_Front(CIRC_BUFF *circBuff)
{
	return circBuff->array[nextIndex(circBuff, circBuff->dataInit)];
}
int CB_Back(CIRC_BUFF *circBuff)
{
	return circBuff->array[circBuff->dataEnd];
}
int CB_Size(CIRC_BUFF *circBuff)
{
	if(circBuff->dataInit<=circBuff->dataEnd)
		return circBuff->dataEnd-circBuff->dataInit;
	else//En el caso que dataInit es mayor que data end
		return circBuff->len-circBuff->dataInit+circBuff->dataEnd;
}

void CB_Push_Front(CIRC_BUFF *circBuff, unsigned int data)
{
	if (CB_Size(circBuff) == circBuff->len-1)
		circBuff->dataEnd = previousIndex(circBuff, circBuff->dataEnd); //Borra el último dato
	circBuff->dataInit= previousIndex(circBuff, circBuff->dataInit);
	circBuff->array[nextIndex(circBuff, circBuff->dataInit)] = data;

}
int CB_Pull_Back(CIRC_BUFF *circBuff)
{
	int retVal = 0;
	if (CB_Size(circBuff) > 0)
	{
		retVal = circBuff->array[circBuff->dataEnd];
		circBuff->dataEnd = previousIndex(circBuff, circBuff->dataEnd);
	}
	return retVal;
}
void CB_Push_Back(CIRC_BUFF *circBuff, unsigned int data)
{
	if (CB_Size(circBuff) == circBuff->len-1)
		circBuff->dataInit = nextIndex(circBuff, circBuff->dataInit); //Borra el último dato
	circBuff->dataEnd = nextIndex(circBuff, circBuff->dataEnd);
	circBuff->array[circBuff->dataEnd] = data;
}
int CB_Find(CIRC_BUFF *circBuff, int data)
{
	int position= circBuff->len,outIndex=0; //En el caso que no lo encuentre devuelve len
	for (int index = nextIndex(circBuff, circBuff->dataInit); existsNextIndex(circBuff, index); index = nextIndex(circBuff, index))
	{
		outIndex++;
		if (circBuff->array[index] == data)
		{
			position = outIndex;
			break;
		}
	}
	return position;
}
int CB_Is_Empty(CIRC_BUFF *circBuff)
{
	return CB_Size(circBuff)==0;
}
void CB_Clear(CIRC_BUFF *circBuff)
{
	circBuff->dataInit=0;
	circBuff->dataEnd=0;
}
/****************************************************LOCAL FUNCTION DEFINITIONS*****************************************************/
unsigned int previousIndex(CIRC_BUFF *circBuff, unsigned int index)
{
	return (index==0) ? circBuff->len-1:index-1;
}
unsigned int nextIndex(CIRC_BUFF *circBuff, unsigned int index)
{
	return (index == (circBuff->len - 1)) ? 0 : index+1;
}
int existsNextIndex(CIRC_BUFF *circBuff, int index)
{
	return index!=circBuff->dataEnd;
}
int existsPreviousIndex(CIRC_BUFF *circBuff, int index)
{
	return index != circBuff->dataInit;
}
